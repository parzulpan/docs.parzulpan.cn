## 简介
这是后端开发系列的数据结构和算法部分，主要分为数据结构篇、经典算法篇和算法设计篇。题目主要来源为LeetCode和剑指Offer，描述语言分为C++、Python和JavaScript。

## 数据结构篇

### 数组
[点我查看**数组**的题解记录](./LeetCode/LeetCode.md#数组)

#### 一、基础知识

#### 二、归纳总结

### 字符串
[点我查看**字符串**的题解记录](./LeetCode/LeetCode.md#字符串)

#### 一、基础知识

#### 二、归纳总结

### 链表
[点我查看**链表**的题解记录](./LeetCode/LeetCode.md#链表)

#### 一、基础知识

#### 二、归纳总结

### 队列
[点我查看**队列**的题解记录](./LeetCode/LeetCode.md#队列)

#### 一、基础知识

#### 二、归纳总结

### 栈
[点我查看**栈**的题解记录](./LeetCode/LeetCode.md#栈)

#### 一、基础知识

#### 二、归纳总结

### 树
[点我查看**树**的题解记录](./LeetCode/LeetCode.md#树)

#### 一、基础知识

#### 二、归纳总结


### 哈希表
[点我查看**哈希表**的题解记录](./LeetCode/LeetCode.md#哈希表)

#### 一、基础知识

#### 二、归纳总结


## 经典算法篇

### 查找算法

### 排序算法

### 动态规划
[点我查看**动态规划**的题解记录](./LeetCode/LeetCode.md#动态规划)

#### 一、基础知识
##### 1. 前言
具体解法来说，动态规划的一般流程就是三部：**暴力的递归解法** -> **带备忘录的递归解法** -> **迭代的动态规划解法**。

思考流程来说，分为以下几步：**找到状态和选择** -> **明确dp向量/函数的定义** -> **寻找状态之间的关系**。

##### 2. 解题要点
* 首先，**动态规划问题的一般形式就是求最值**。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如求**最长**递增子序列、**最小**编辑距离等等。当然，有的时候可能不会这么直白，但是仔细分析还是求最值的问题。
* 然后，既然是求最值，那么核心问题就是**穷举**。但是，动态规划的穷举有点特殊，因为这类问题存在 **`重叠子问题`**，如果单纯的暴力穷举可能效率很低，所以需要**备忘录**或者**DP表**来优化穷举过程，避免不必要的计算。
* 而且，动态规划一定会具备**`最优子结构`**，才能通过子问题的最值得到原问题的最值。
* 另外，虽然核心思想是穷举求最值，但是有时候穷举所有可行解非常困难，只有列出正确的**`状态转移方程`**才能正确地穷举。
* 总结起来，重叠子问题、最优子结构、状态转移方程就是动态递归**三要素**。
* 经验来说，写出状态转移方程比较是相对比较困难的，它的**思维框架**：`明确base case -> 明确状态 -> 明确选择 -> 定义dp向量/函数`。
```c++
// 初始化 base case
dp[0][0][...] = base;

// 进行状态转移
for(auto 状态1: 状态1的所有取值) {
    for(auto 状态2: 状态2的所有取值) {
        for(auto 状态x: 状态x的所有取值) {
            dp[状态1][状态2][...] = 求最值(选择1, 选择2, ...)
        }
    }
}
```
* **自顶向下**：从上向下延伸，都是从一个规模较大的原问题比如说 f(20)，向下逐渐分解规模，直到 f(1) 和 f(2) 这两个 base case，然后逐层返回答案，这就叫自顶向下。[斐波那契数 解法2](./LeetCode/leetcode/editor/cn/fibonacci-number.cpp)
* **自底向上**：直接从最底下，最简单，问题规模最小的 f(1) 和 f(2) 开始往上推，直到推到我们想要的答案 f(20)，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由**循环迭代**完成计算。[斐波那契数 解法3](./LeetCode/leetcode/editor/cn/fibonacci-number.cpp)
* f(n) = f(n-1) + f(n-2)，它就是上述问题的数学形式。千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程。只要写出暴力解，优化方法无非是用备忘录或者 DP表，再无奥妙可言。
* **状态压缩技巧**：如果发现每次状态转移只需要 DP表 中的一部分，那么可以尝试用状态压缩来缩小 DP表 的大小，只记录必要的数据。一般来说是把一个二维的 DP表 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。[斐波那契数 解法4](./LeetCode/leetcode/editor/cn/fibonacci-number.cpp)
* 计算机解决问题其实没有任何奇技淫巧，**它唯一的解决办法就是穷举**，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。[零钱兑换 解法1 解法2 解法3](./LeetCode/leetcode/editor/cn/coin-change.cpp)

#### 二、归纳总结
##### 1. 0-1背包问题
* **题目提炼**出来大概都是这么个意思：现在有一个最多可装下重量为W的背包和N个有价值有重量的物品，问你这个背包最多能装多少价值物品。
* 这很明显的就是一个典型的动态规划问题，满足三要素：**重叠子问题、最优子结构、状态转移方程**。物品不可分割，要么不装，要么装，或许这就是0-1吧。
* **第一步：明确状态**。什么才能描述一个问题？很明显，**背包的容量**和**可选择的物品**就是状态。
* **第二步：明确选择**。对于每个物品，能做的选择是什么？很明显，**装进背包**和**不装进背包**就是选择。
* **第三步：定义dp向量/函数**。即如何把状态表达出来？由于有**两个状态**，所以定义一个**二维向量**，一维表示可选择的物品，另一维表示背包的容量。即**`dp[i][w]`的定义**为：对于前i个物品，当前背包的容量为w，这种情况下可以装的最大价值是`dp[i][w]`。所以 **base case** 即为 `dp[0][...] = dp[...][0] = 0` 。
* 总结以上三步，得到**框架**：
```c++
vector<vector<int>>dp(N+1, vector<int>(W+1, 0));
dp[0][...] = 0;
dp[...][0] = 0;

for(auto i: [1...N])
    for(auto w: [1...W]) {
        dp[i][w] = max(把物品i装进背包, 不把物品i装进背包);
        // i从1开始，翻译为
        dp[i-1][w] = max(dp[i-1][w-wt[i-1]] + val[i-1], dp[i-1][w])
}
```

* 翻译成**C++描述**：
```c++
class Solution {
public:
    int backpack(int W, int N, vector<int>& wt, vector<int>& val) {
        // 初始化 和 base case
        vector<vector<int>>dp(N+1, vector<int>(W+1, 0));
        for(int i = 1; i <= N; ++i) {
            for(int w = 1; w < = W; ++w) {
                if(w - wt[i-1] < 0) {
                    // 容量不够，只能选择不装进背包
                    dp[i][w] = dp[i-1][w];
                } else {
                    // 装进背包和不装进背包，择优选择
                    dp[i][w] = max(dp[i-1][w-wt[i-1]] + val[i-1], dp[i-1][w]);
                }
            }
        }   
    }
};
```

##### 2. 子集背包问题
* **一个典型题目**：给定一个只包含正整数的非空数组。是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。[分割等和子集](./LeetCode/leetcode/editor/cn/partition-equal-subset-sum.cpp)
* 可以将这个**典型题目转换成背包问题**：求出数组和，记为`sum`，那么给一个可装下重量为 `sum / 2`  的背包和 `N` 个物品，每个物品重量为` nums[i]`，现在让你装物品，是否存在一种装法，能够恰好把背包装满？
* **第一步：明确状态**。**背包的容量 `sum / 2` **和**可选择的物品**就是状态。
* **第二步：明确选择**。**装进背包**和**不装进背包**就是选择。
* **第三步：定义dp向量/函数**。`dp[i][j] = x`，表示对于前 i 个物品，当前背包的容量为 j 时，若 x 为 true，则说明可以恰好将背包装满，若 x 为 false，则说明不能恰好将背包装满。**base case** 就是 `dp[..][0] = true` 和 `dp[0][..] = false`，因为背包没有空间的时候，就相当于装满了，而当没有物品可选择的时候，肯定没办法装满背包。
* 那么，**状态转移的逻辑**为：1. 如果不把 `nums[i]` 算入子集，或者说你不把这第 i 个物品装入背包，那么是否能够恰好装满背包，取决于上一个状态 `dp[i-1][j]`，继承之前的结果。2. 如果把 `nums[i]` 算入子集，或者说你把这第 i 个物品装入了背包，那么是否能够恰好装满背包，取决于状态 `dp[i-1][j-nums[i-1]]`。

##### 3. 完全背包问题
* **一个典型题目**：给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 [零钱兑换 II](./LeetCode/leetcode/editor/cn/coin-change-2.cpp)
* 可以将这个**典型题目转换成背包问题**：有一个背包，最大容量为 `amount`，有一系列物品 `coins`，每个物品的重量为 `coins[i]`，每个物品的**数量无限**。请问有多少种方法，能够把背包恰好装满？
* **第一步：明确状态**。**背包的容量 `amount` **和**可选择的物品**就是状态。
* **第二步：明确选择**。**装进背包**和**不装进背包**就是选择。
* **第三步：定义dp向量/函数**。`dp[i][j] = x`，若只使用前i个物品，当背包容量为j时，有x中方法可以装满背包。**base case** 为 `dp[0][..] = 0`， `dp[..][0] = 1`。因为如果不使用任何硬币面值，就无法凑出任何金额；如果凑出的目标金额为 0，那么就是唯一的一种凑法。


背包问题推荐题目：
[单词拆分](./LeetCode/leetcode/editor/cn/word-break.cpp)
[单词拆分 II](./LeetCode/leetcode/editor/cn/word-break-ii.cpp)
[零钱兑换](./LeetCode/leetcode/editor/cn/coin-change.cpp)
[零钱兑换 II](./LeetCode/leetcode/editor/cn/coin-change-2.cpp)
[组合总和 Ⅳ](./LeetCode/leetcode/editor/cn/combination-sum-iv.cpp)
[分割等和子集](./LeetCode/leetcode/editor/cn/partition-equal-subset-sum.cpp)
[一和零](./LeetCode/leetcode/editor/cn/ones-and-zeroes.cpp)
[目标和](./LeetCode/leetcode/editor/cn/target-sum.cpp)

##### 4. 子序列问题


### 回溯算法
[点我查看**回溯算法**的题解记录](./LeetCode/LeetCode.md#回溯算法)

#### 一、基础知识

#### 二、归纳总结

### 贪心算法

### 滑动窗口

## 算法设计篇
待更新...

## 参考致谢
参考和借鉴以下开源项目和资源：
* [labuladong/fucking-algorithm](https://github.com/labuladong/fucking-algorithm)

感谢以上开源项目和资源！
