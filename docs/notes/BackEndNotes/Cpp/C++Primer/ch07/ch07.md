# 第七章 类
## 一、定义抽象数据类型
* **类背后的基本思想**：**数据抽象（data abstraction）**和**封装（encapsulation）**。
* 数据抽象是一种依赖于**接口（interface）**和**实现（implementation）**分离的编程技术。

### 1. 类成员
* 必须在类的内部声明，不能在其他地方增加成员。
* 成员可以是数据，函数，函数别名。

### 2. 类的成员函数
* 成员函数的**声明**必须在类的内部。
* 成员函数的**定义**既可以在类的内部也可以在外部。
* 使用 **点运算符 .** 调用成员函数。
* 必须对任何const或者引用类型成员以及默认构造函数的类类型的任何成员使用初始化式。**ConstRef::ConstRef(int ii): i(ii), ci(ii), ri(ii) { };**
* **默认实参**：Sales_item(const std::string &book): isbn(book), units_sold(0), revenue(0.0) { };
* ***this**
    * 每个成员函数都有一个额外的，**隐含的形参this**。
    * this总是指向当前对象，因此**this是一个常量指针**。
    * 形参表后面的const，该表了隐含的形参this的类型，例如 **bool same_isbn(const Sales_item &rhs) const;** ，这种函数称为“**常量成员函数**”（this指向的当前对象是常量）。
    * return *this; 可以让成员函数连续调用。
    * **const成员函数**：this是指向const类类型的const指针(不可以改变this所指向的值，不可以改变this保存的地址)。
    * **非const成员函数**：this是指向类类型的const指针(可以改变this所指向的值，不可以改变this保存的地址)。
    
### 3. 非成员函数
* 和类相关的非成员函数，定义和声明都应该在类的外部。

### 4. 类的构造函数
* 类通过一个或者几个特殊的成员函数来控制其对象的初始化过程，这些函数叫做**构造函数**。
* 构造函数是特殊的成员函数，且与类同名。它在类的public部分。
* **=default** 要求编译器合成默认的构造函数。通常在定义自己的构造函数前调用它一次。(C++11)
* **初始化列表**：冒号和花括号之间的代码： Sales_item(): units_sold(0), revenue(0.0) { }

### 5. 拷贝、赋值和析构
* 类中所有分配的资源都应该直接以类的数据成员形式存储。

## 二、访问控制与封装
* **访问说明符(access specifiers)**：
    * **public**：定义在 public后面的成员在整个程序内可以被访问； public成员定义类的接口。
    * **private**：定义在 private后面的成员可以被类的成员函数访问，但不能被使用该类的代码访问； private隐藏了类的实现细节。
* **使用class或者struct**：都可以被用于定义一个类，**唯一的区别就是默认的访问权限**。
    * 使用class：在第一个访问说明符之前的成员都是private的。
    * 使用struct：在第一个访问说明符之前的成员都是public的。

### 1. 友元
* 允许特定的**非成员函数**访问一个类的**私有成员**。
* 友元的声明以关键字 **friend** 开始。通常将友元声明成组地放在**类定义的开始或者结尾**。
```c++
class Sales_data {
friend Sales_data add(const Sales_data&, const Sales_data&);

public:
    Sales_data() = defalut;
    Sales_data(const std::string &s, unsigned n, double p): bookNo(s), units_sold(n), revenue(p*n) {}

private:
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
```

### 2. 封装的益处
* 确保用户的代码不会无意间破坏封装对象的状态。
* 被封装的类的具体实现细节可以随时改变，而无需调整用户级别的代码

## 三、类的其他特性
* **成员函数作为内联函数inline**:
    * 在类的内部，常有一些规模较小的函数适合于被声明为内联函数
    * **定义**在类内部的函数是**自动内联**的。
    * 在类外部定义的成员函数，也可以在声明时显式地加上inline。
* **可变数据成员(mutable data member)**:
    * mutable size_t access_ctr;
    * 永远不会是const，即使它是const对象的成员。
* **类类型**：
    * 每个类定义了唯一的类型。

## 四、类的作用域
* 每个类都会定义它自己的作用域。在类的作用域之外，普通的数据和函数成员只能由引用、对象、指针使用成员访问运算符来访问。
* 函数的返回类型通常在函数名前面，因此当成员函数定义在类的外部时，返回类型中使用的名字都位于类的作用域之外。
* 如果成员使用了外层作用域中的某个名字，而该名字代表一种**类型**，则类不能在之后重新定义该名字。
* **类的定义分两步处理**：
    * 首先，编译成员的声明。
    * 直到类全部可见后才编译函数体。
* 类型名的定义通常出现在类的开始处，这样就能确保所有使用该类型的成员都出现在类名的定义之后。

## 五、构造函数再探
### 1. 构造函数初始化列表
* 构造函数的初始值有时必不可少。如果成员是const、引用，或者属于某种未提供默认构造函数的类类型，我们必须通过构造函数初始值列表为这些成员提供初值。
* **建议使用构造函数初始值**。
* 最好令构造函数初始值的顺序与成员声明的**顺序保持一致**。建议尽量避免使用某些成员初始化其他成员。

### 2. 委托构造函数
* 委托构造函数将自己的职责委托给了其他构造函数。
```c++
class Sales {
public:
    // 非委托构造使用对应的实参初始化成员
    Sales(std::string s, unsigned cnt, double price): bookNo(s), unit(cnt), revenue(cnt*price) {}  
    
    // 其余构造函数全部委托给另一个构造函数
    Sales(): Sales("", 0, 0) {}
    Sales(std::string s): Sales(s, 0, 0) {}
    Sales(std::istream &is): Sales() {read(is, *this);}
};
```

### 3. 默认构造函数的作用
* 当对象被**默认初始化或值初始化**时自动执行默认构造函数。默认初始化的发生情况：
    * 当在块作用域内不使用任何初始值定义一个非静态变量或者数组时。
    * 当一个类本身含有类类型的成员且使用合成的默认构造函数时。
    * 当类类型的成员没有在构造函数初始值列表中显式地初始化时。
* **值初始化**的发生情况：
    * 在数组初始化的过程中如果提供的初始值数量少于数组的大小时。
    * 当不使用初始值定义一个局部静态变量时。
    
### 4. 隐式的类类型转换
* 如果构造函数**只接受一个实参**，则它实际上定义了转换为此类类型的**隐式转换机制**。这种构造函数又叫**转换构造函数（converting constructor）**。
* 编译器只会自动地执行**仅一步**类型转换。
* **抑制**构造函数定义的隐式转换：
    * 将构造函数声明为**explicit**加以阻止。
    * explicit构造函数**只能用于直接初始化**，**不能用于拷贝形式的初始化**。
    
### 5. 聚合类
* 聚合类使得用户**可以直接访问其用户**，它需要满足以下要求：
    * 所有成员都是public的。
    * 没有定义任何构造函数。
    * 没有类内初始值。
    * 没有基类，也没有virtual函数。
```c++
// 聚合类例子
struct Data {
    int val;
    string s;
};
```
* 可以使用一个花括号括起来的成员初始值列表，初始值的顺序必须和声明的顺序一致。
```c++
// 聚合类使用
Data d = {0, "DD"};
```
### 6. 字面值常量类
* constexpr函数的参数和返回值必须是字面值。
* **字面值类型**：除了算术类型、引用和指针外，某些类也是字面值类型。
* **数据成员都是字面值类型的聚合类是字面值常量类**。
* 如果不是聚合类，则必须满足下面所有条件：
    * 数据成员都必须是字面值类型。
    * 类必须**至少含有一个**constexpr构造函数。
    * 如果一个数据成员含有类内部初始值，则内置类型成员的初始值必须是一条常量表达式；或者如果成员属于某种类类型，则初始值必须使用成员自己的constexpr构造函数。
    * 类必须**使用析构函数的默认定义**，该成员负责销毁类的对象。

## 六、类的静态成员
* 非static数据成员存在于类类型的每个对象中。但是static数据成员独立于该类的任意对象而存在。
* 每个static数据成员是与类关联的对象，并不与该类的对象相关联。
* **声明**：
    * 声明之前加上关键词static。
* **使用**：
    * 使用作用域运算符::直接访问静态成员:r = Account::rate();
    * 也可以使用对象访问：r = ac.rate();
* **定义**：
    * 在类外部定义时不用加static。
* **初始化**：
    * 通常不在类的内部初始化，而是在定义时进行初始化，如 double Account::interestRate = initRate();
    * 如果一定要在类内部定义，则要求必须是字面值常量类型的constexpr。