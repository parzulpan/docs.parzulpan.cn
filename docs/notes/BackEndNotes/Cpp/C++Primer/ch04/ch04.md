# 第四章 表达式
## 一、基础
* **重载运算符**：当运算符作用在类类型的运算对象时，用户可以自行定义其含义。
* **左值和右值**：
    * C中：左值可以在表达式左边，右值不能。
    * C++中：当一个对象被用作右值的时候，用的是对象的值（内容）。被用做左值时，用的是对象的身份（在内存中的位置）。

## 二、算术运算符
* **溢出**：当计算的结果超出该类型所能表示的范围时就会产生溢出。

## 三、逻辑和关系运算符
* **短路求值**：逻辑与运算符和逻辑或运算符都是先求左侧运算对象的值再求右侧运算对象的值，**当且仅当左侧运算对象无法确定表达式的结果时才会计算右侧运算对象的值**。

## 四、赋值运算符
* 如果赋值运算的左右侧运算对象类型不同，则右侧运算对象将转换成左侧运算对象的类型。
* 赋值运算符满足右结合律，这点和其他二元运算符不一样。 val = val1 = 0;等价于val = (val1 = 0);
* 赋值运算优先级比较低。

## 五、成员访问运算符
* 

## 六、条件运算符
* **条件运算符（?:）**：允许把简单的if-else逻辑嵌入到单个表达式中去，按照如下形式：cond? expr1: expr2

## 七、位运算符
* 位运算符是作用于**整数类型**的运算对象。
* 二进制位向左移（<<）或者向右移（>>），移出边界外的位就被舍弃掉了。
* 位取反（~）、与（&）、或（|）、异或（^）

## 八、sizeof运算符
* 返回一条表达式或一个类型名字所占的字节数。返回的类型是 size_t。
* 两种形式： sizeof (type)和 sizeof expr。
* sizeof运算符的结果部分地依赖于其作用的类型：
    * 对char或者类型为char的表达式执行sizeof运算，结果为1。
    * 对引用类型执行sizeof运算得到被引用对象所占空间的大小。
    * 对指针执行sizeof运算得到指针本身所占空间的大小。
    * 对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需要有效。
    * 对**数组**执行sizeof运算得到整个数组所占空间的大小，等价于对数组中所有的元素各执行一次sizeof运算并将结果求和。注意：sizeof运算不会把数组转换为指针来处理。
    * 对**string或者vector对象**执行sizeof运算只返回该类型固定部分的大小，不会计算对象中的元素占用了多少空间。


## 九、逗号运算符
* 

## 十、类型转换
### 1. 隐式类型转换
* 比 int类型小的整数值先提升为较大的整数类型。
* 条件判断中，非布尔转换成布尔。
* 初始化中，初始值转换成变量的类型。
* 算术运算或者关系运算的运算对象有多种类型，要转换成同一种类型。
* 函数调用时。
* 数组转换成指针

### 2. 显式类型转换
2.1. 命名的强制类型转换，格式为：**cast-name<type>(expression)**
。其中，type：转换的类型；expression：需要转换的值；cast-name：static_cast、dynamic_cast、const_cast和reinterpret_cast。

2.2. **static_cast**：任何具有明确定义的类型转换，只要不包含底层const，都可以使用它。
```c++
// 进行强制类型转换以便执行浮点数除法
double slope = static_cast<double>(j) / i;


void *p = &d;   // 任何非常量对象的地址都能存入void *
// 将void * 转换回初始的指针类型
double *dp = static_cast<double*>(p);
```                                                                     

2.3. **dynamic_cast**：支持运行时类型识别。

2.4. **const_cast**：只能改变运算对象的底层const。一般可用于去除const性质。
```c++
const char *pc; 
char *p = const_cast<char*>(pc)
```

2.5. **reinterpret_cast**：通常为运算对象的位模式提供低层次上的重新解释。它本质上依赖于机器，要想安全的使用它必须对涉及的类型和编译器实现转换的过程非常了解。

2.6. 应该避免强制类型转换。

## 十一、运算符优先级表
* 