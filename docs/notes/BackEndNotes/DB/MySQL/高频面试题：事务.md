# 高频面试题：事务

## 事务

事务是逻辑上的一组操作，或者说一个独立的工作单元。事务内的语句，要么全部执行成功，要么全部执行失败。

## 事务的特性（ACID）

* **原子性(`Atomicity`)** ：一个事务被视为一个不可分割的最小工作单元，整个事务的所有操作要么全部提交成功，要么全部失败回滚。对于一个事务来说，不可能只执行其中的一部分操作。
* **一致性(`Consistency`)** ：数据库总是从一个一致性的状态转换到另外一个一致性的状态。即使中途崩溃。因为事务没有提交，所以事务中所做的修改也不会被保存到数据库中。
* **隔离性(`Isolation`)** ：**通常来说**，一个事务的修改在最终提交之前，对其他事务是不可见的。由不同的隔离级别决定。
* **持久性(`Durability`)** ：一旦事务提交，则其所有的修改就会永远保存到数据库中。持久性是个模糊的概念，因为实际上持久性也分为很多不同的级别。

理解**ACID**：

* 它们不是一种平级关系。
* 事务的执行结果是正确的必要条件是满足一致性。
* 在无并发的情况下，事务串行执行，隔离性一定能满足，此时只有满足原子性，才能满足一致性。
* 在并发的情况下，事务并行执行，此时只有满足隔离性和原子性，才能满足一致性。
* 事务满足持久化是为了能应对系统崩溃的情况。

## 隔离级别

在SQL标准中定义了四种隔离级别，每一种级别都规定了一个事务中所做的修改，哪些在事务内和事务间是可见的，哪些是不可见的。

较低级别的隔离通常可以执行更高的并发，系统的开销也更低。

**四种隔离级别**：

* `READ UNCOMMITTED`(未提交读)：**事务中的修改，即使没有提交，对其他事务也都是可见的**。事务可以读取未提交的数据，这也被称为**脏读**(`Dirty Read`)。这种级别会导致很多问题，从性能上讲，它不会比其他级别好很多，在实际应用一般很少使用它。
* `READ COMMITTED`(提交读)：**一个事务提交之前，所做的任何修改对其他事务都是不可见的**。它也被称为**不可重复读**，因为两次执行同样的查询，可能会得到不一样的结果。大多数数据库系统的默认隔离级别都是提交读，但是MySQL不是。
* `REPEATABLE READ`(可重复读)：**它保证了在同一个事务中多次读取同样记录的结果是一致的，解决了脏读的问题**。但是在理论上，他还是无法解决另外一个**幻读**(`Phantom Read`)的问题，所谓幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生**幻行**(`Phantom Row`)。InnoDB等存储引擎通过**多版本并发控制**(`MVCC`)解决了幻读的问题。**MySQL默认隔离级别是可重复读**。
* `SERIALIZABLE`(**可串行化**)：**它是最高的隔离级别。它通过强制事务执行，解决幻读的问题**。即它会在读取每一行数据上都加锁，所以可能导致大量的超时和锁争用的问题。在实际应用一般很少使用它。

总结：

| 隔离级别 | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
| :--- | :--- | :--- | :--- | :--- |
| 未提交读 | Y | Y | Y | N |
| 提交读 | N | Y | Y | N |
| 可重复读 | N | N | Y |  N|
| 可串行化 | N | N | N | N |

