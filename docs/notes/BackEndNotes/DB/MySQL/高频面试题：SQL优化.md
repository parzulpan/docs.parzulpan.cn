# 高频面试题：SQL优化

## 根本的优化之道

* 减少查询字段数。
* 表关联尽量用主键。
* 查询条件尽量避免模糊查询。
* 避免使用排序字段，排序字段尽量使用主键。
* 尽量使用限制查询条件。
* 查询条件使用有效索引。

## 关于字段

* 尽量使用TINYINT、SMALLINT、MEDIUM_INT作为整数类型而非INT，如果非负则加上UNSIGNED
* VARCHAR的长度只分配真正需要的空间
* 使用枚举或整数代替字符串类型
* 尽量使用TIMESTAMP而非DATETIME，
* 单表不要有太多字段，建议在20以内
* 避免使用NULL字段，很难查询优化且占用额外索引空间
* 用整型来存IP

## 关于索引

* 索引并不是越多越好，要根据查询有针对性的创建，考虑在WHERE和ORDER BY命令上涉及的列建立索引，可根据EXPLAIN来查看是否用了索引还是全表扫描
* 应尽量避免在WHERE子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描
* 值分布很稀少的字段不适合建索引，例如"性别"这种只有两三个值的字段
* 字符字段只建前缀索引
* 字符字段最好不要做主键
* 不用外键，由程序保证约束
* 尽量不用UNIQUE，由程序保证约束
* 使用多列索引时主意顺序和查询条件保持一致，同时删除不必要的单列索引

## 关于查询语句

* 可通过开启慢查询日志 ` set global slow_query_log=on; ` 来找出较慢的SQL
* 不做列运算：` SELECT id WHERE age + 1 = 10; `，任何对列的操作都将导致表扫描，它包括数据库教程函数、计算表达式等等，查询时要尽可能将操作移至等号右边
* sql语句尽可能简单：一条sql只能在一个cpu运算；大语句拆小语句，减少锁时间；一条大sql可以堵死整个库
* 不用SELECT *
* OR改写成IN：OR的效率是n级别，IN的效率是log(n)级别，in的个数建议控制在200以内
* 不用函数和触发器，在应用程序实现
* 避免%xxx式查询
* 少用JOIN
* 使用同类型进行比较，比如用'123'和'123'比，123和123比
* 尽量避免在WHERE子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描
* 对于连续数值，使用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5
* 列表数据不要拿全表，要使用LIMIT来分页，每页数量也不要太大

## 为查询缓存优化你的查询

* 大多数MySQL服务器都开启了查询缓存，而且会被MySQL的数据库引擎处理。当很多相同的查询被执行了多次的时候，这些查询结果就会被放到一个缓存中。
* 关键点在于，有时写的查询语句会让MySQL不使用缓存，比如：

```sql
# 缓存不开启
select username from user where signup_date >= CURDATE();

# 缓存开启
today = date("Y-m-d");
select username from user where signup_date >= '$today';
```

* 由于MySQL的查询对某些函数不起作用，因为这些函数的返回是不固定的，所以需要用一个变量来代替MySQL函数，从而开启缓存。

## EXPLAIN你的SELECT查询

* 使用explain可以知道MysQL如何处理你的SQL语句的，这样可以帮助分析查询语句或者表结构的性能瓶颈。
* 使用explin还会告诉你索引主键是如何被利用的、数据表如何被搜索和排序的等等。
* 查看rows列可以让我们找到潜在的性能问题。

```sql
# 方法1：使用子查询
explain select prod_id, prod_name
from products
where vend_id = (select vend_id
                 from products
                 where prod_id = 'DTNTR');

# 输出
+------+-------------+----------+-------+---------------------+---------+---------+-------+------+-------------+
| id   | select_type | table    | type  | possible_keys       | key     | key_len | ref   | rows | Extra       |
+------+-------------+----------+-------+---------------------+---------+---------+-------+------+-------------+
|    1 | PRIMARY     | products | ALL   | fk_products_vendors | NULL    | NULL    | NULL  |   14 | Using where |
|    2 | SUBQUERY    | products | const | PRIMARY             | PRIMARY | 40      | const |    1 |             |
+------+-------------+----------+-------+---------------------+---------+---------+-------+------+-------------+

# 方法2：使用自联结
explain select p1.prod_id, p1.prod_name
from products as p1, products as p2
where p1.vend_id = p2.vend_id and p2.prod_id = 'DTNTR';

# 输出
+------+-------------+-------+-------+-----------------------------+---------+---------+-------+------+-------------+
| id   | select_type | table | type  | possible_keys               | key     | key_len | ref   | rows | Extra       |
+------+-------------+-------+-------+-----------------------------+---------+---------+-------+------+-------------+
|    1 | SIMPLE      | p2    | const | PRIMARY,fk_products_vendors | PRIMARY | 40      | const |    1 |             |
|    1 | SIMPLE      | p1    | ALL   | fk_products_vendors         | NULL    | NULL    | NULL  |   14 | Using where |
+------+-------------+-------+-------+-----------------------------+---------+---------+-------+------+-------------+

```

## 当只要一行数据使用使用LIMIT 1

* 当你查询表的有些时候，你已经知道结果只会有一条结果，加上 LIMIT 1 可以增加性能。
* 因为MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查少下一条符合记录的数据。

```sql
# 没有效率的
explain select order_num from orders where cust_id = 10001;

# 有效率的
explain select order_num from orders where cust_id = 10001 limit 1;
```

## 大表数据查询，如何优化

* 优化shema、sql语句和索引
* 加缓存
* 主从复制，读写分离
* 垂直拆分
* 水平拆分

## 超大分页怎么处理

* 数据库层面
* 业务层面，建议减少这种请求

## 为什么要尽量设定一个主键

* 主键是数据库确保数据行在整张表唯一性的保障，即使业务上不要求表有主键，但是也建议添加一个自增ID作为主键。设定了主键，在后续的操作中能更加快速以及确保操作数据的范围安全。

## 主键使用自增ID还是UUID

* 建议使用自增ID。
* 因为在InnoDB引擎中，主键索引是作为聚簇索引存在的，即B+树叶子节点同时存储了索引和数据，如果使用自增ID，只需要向后一直排就可以了。如果使用UUID，由于当前的ID和原来的ID大小不确定，会造成非常多的数据插入和移动，导致产生很多内存碎片，进而造成性能的下降。
* 如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。

## 为什么字段要定义为NOT NULL

* 因为 NULL 需要更多的存储空间并且 NULL 无法参与某些运算。

## 如果要存储用户的密码散列，应该采用什么字段进行存储

* 密码散列，盐，用户身份证号等固定长度的字符串应该使用CHAR而不是VARCHAR来存储，这样可以节省空间且提高检索效率。
