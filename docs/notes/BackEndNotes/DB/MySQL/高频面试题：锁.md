# 高频面试题：锁

## 从锁的粒度角度，MySQL都有哪些锁

* 行级锁：它是MySQL中最小粒度的锁定机制，行级锁分为共享锁和排他锁。特点是：锁定粒度最小，生锁冲突的概率最低，并发度最高；开销大，加锁慢，会出现死锁；只在存储引擎层实现。
* 表级锁：它是MySQL中最大粒度和最基本的锁定机制，表级锁分为读锁和写锁。特点是：锁定粒度最大，生锁冲突的概率最高，并发度最低；开销小，加锁快，不会出现死锁；
* 页级锁：粒度和效果介于行级锁和表级锁之间。

表级锁会锁定整张表，一个用户对表进行写操作，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。

## 从锁的类别角度，MySQL都有哪些锁

* 共享锁: 又叫做读锁。当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。
* 排他锁: 又叫做写锁。当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，它和其他的排他锁，共享锁都互斥。

## 隔离级别与锁的关系

* 在**未提交读**级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突。所以可能会导致脏读、不可重复读、幻读。
* 在**提交读**级别下，读数据需要加共享锁，但是在语句执行完之后释放共享锁。所以可以阻止脏读，可能会导致不可重复读、幻读。
* 在**可重复读**级别下，读数据需要加共享锁，但是在事务提交之前并不释放共享锁。所以可以阻止脏读、不可重复读，可能会导致幻读。
* 在**可串行化**级别下，会在读取每一行数据上都加锁，并一直持有锁，直到事务完成。所以可以阻止脏读、不可重复读、幻读。

## InnoDB的行级锁如何实现

* 是通过给索引上的索引项加锁来实现的。这种实现意味着只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁。

## InnoDB的锁算法

* `Record Lock`：单个行记录上的锁。
* `Gap Lock`：间歇锁，锁定一个范围，不包括基本本身。
* `Next-Key Lock`：锁定一个，包含记录本身。

## 什么是死锁，怎么解决

* 死锁：是指两个或多个事务在同一个资源上相互占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。
* 当多个事务以不同的顺序锁定资源时，就可能产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。
* 为了解决这种问题，数据库系统实现了各种**死锁检测**和**死锁超时**机制。一种好的方式是，检测到死锁的循环依赖，并立即返回一个错误。一种不太好的方式是，当查询的时间达到锁等待超时的设定后放弃锁请求。
* InnoDB目前处理死锁的方式是，将持有最少行级排它锁的事务进行回滚。

## 什么是乐观锁和悲观锁，怎么实现

并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和一致性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。

* 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。
  * 实现方式：般会使用数据库中的锁机制。
* 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过版本的方式来进行锁定。乐观锁不能解决脏读的问题。
  * 实现方式：一般会使用版本号机制或CAS算法实现。

